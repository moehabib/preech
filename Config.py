import json
import re,os
import sublime, sublime_plugin

class Config(sublime_plugin.TextCommand):

	def is_array(self,var):
	    return isinstance(var, (list, tuple))


	def run(self,edit):
		dir = sublime.packages_path()
		pyconf =  os.path.join(dir,"preech\config\python.gram.json")
		fobj = open(pyconf, "r")





		jsonConfig = fobj.readlines()

		jsonList =  json.loads("".join(jsonConfig) )
		aliases = self.getAliases(jsonList)


		print '----------------------'

		#write each alias from the list into the grammar file that's read by sphinx
		self.createGrammarFile(aliases)

		#generate the processing code that will be used to process the input
		#received from sphinx
		self.generateCode(jsonList)

		fobj.close()

	def getAliases(self, jsonList):
		#we return a list of UNIQUE aliases
		#by maintaining a dictionary structure and storing everything as keys,
		#we avoid duplicates, which is desired

		aliaslist = {}

		for i in jsonList:
			#skip the settings key
			if (i == "settings"):
				continue
			#for each one if it's an array, loop over it
			if (self.is_array(jsonList[i])):
				for j in jsonList[i]:
					aliaslist[ j['alias'] ] = None
					print j['alias']
			#otherwise, just get insert and alias
			else:
				aliaslist[ jsonList[i]['alias'] ] = None
				print jsonList[i]['alias']


		return aliaslist

	def createGrammarFile(self,aliases):

		dir = sublime.packages_path()
		gramfile =  os.path.join(dir,"preech/sphinx/edu/cmu/sphinx/demo/helloworld/core.gram")
		sphinxfile = open(gramfile,"w")
		sphinxfile.write("#JSGF V1.0;\n\n")

		sphinxfile.write('/* Grammar generated by preech config */\n\n')
		sphinxfile.write("grammar core;\n\n")

		rules = "public <start> ="

		for alias in aliases:
			rules = rules + " | " 	+ alias
			print alias

		rules = rules.replace('|','', 1) + ";"
		sphinxfile.write(rules)

		#close all the open files
		sphinxfile.close()


		#this function generates the python code
		#That is going to be able to accept it's 
		#input is the parsed json config, output is 
		#written to the file 'InputProcessor.py'
	def generateCode(self, grammarList):

		dir = sublime.packages_path()
		codegenfile =  os.path.join(dir,"preech/inputProcessor.py")
		inputfile = open(codegenfile,"w")
		
		inputfile.write("#this file has been generated\n")
		inputfile.write("#by PREECH config.py for processing\n")
		inputfile.write("#The input received by sphinx\n")

		inputfile.write("import sublime,sublime_plugin\n")
		inputfile.write("import time\n")
		inputfile.write("try:\n")		
		inputfile.write("    from Queue import Queue, Empty\n")
		inputfile.write("except ImportError:\n")		
		inputfile.write("    from queue import Queue, Empty  # python 3.x\n")		
		



		inputfile.write("\n\nclass inputProcessor():\n")
		inputfile.write("	speechQue = None\n")
		inputfile.write("	actionQue = None\n")
		inputfile.write("	def __init__(self,speechQue,actionQue):\n")
		inputfile.write("		self.speechQue = speechQue\n")
		inputfile.write("		self.actionQue = actionQue\n")
		inputfile.write("	def __next_word(self):\n")
		inputfile.write("		while ( True ):\n")
		inputfile.write("			word = self.getNextInput() \n")
		inputfile.write("			if (word is False):\n")
		inputfile.write("				time.sleep(1)\n")
		inputfile.write("			else:\n")
		inputfile.write("				break\n")
		inputfile.write("		return word\n")
		inputfile.write("	def getNextInput(self):\n")
		inputfile.write("		try:  line = self.speechQue.get_nowait()\n")
		inputfile.write("		except Empty:\n")
		inputfile.write("		    return False\n")
		inputfile.write("		else: # got line\n")
		inputfile.write("		    return line\n")

		inputfile.write("	def " + "getSym" + "(self):\n")
		inputfile.write("		value = self.__next_word()\n")
		inputfile.write("		if (False):\n")
		inputfile.write("			pass\n")		
		inputfile.write("		elif (value =='continue'):\n")
		inputfile.write("			pass\n")
		inputfile.write("		else:\n")
		inputfile.write("			self.getSym()\n")



		for i in grammarList:
			#skip the settings key\n")
			if (i == 'settings'):
				continue
			print i


			inputfile.write("\n\n	def " + i + "(self):\n")
			#inputfile.write("		value =  recognizer.getNextWord():\n")
			inputfile.write("		value = self.__next_word()\n")

			inputfile.write("		if (False):\n")
			inputfile.write("			pass\n")
			#Keeping everything in one loop makes everything cleaner
			#inside the loop we check if it's an array or no		
			for j in grammarList[i]:
				if (self.is_array(grammarList[i])):
					rule=j
				else:
					rule=grammarList[i]

				nonterminals = r"\[\[[^\]]*\]\]"
				toinsert = re.sub( nonterminals, "", rule['insert'] )
				alias = rule['alias']

				inputfile.write("		elif (value =='" + alias + "'):\n")
				inputfile.write("			act = action()\n")
				inputfile.write("			act.setInsert('" + toinsert + "')\n")
				inputfile.write("#			self.view.insert(edit, pos, '"+ toinsert + "' )\n")

				regex = re.compile( nonterminals )
				decrement = 0
				for m in regex.finditer(j['insert']): 
					nontermName = m.group()[3:-2]
					nontermSize =  len(m.group())
					cursorGoto = m.start()
					nontermChar = m.group()[2]

					inputfile.write("			act.setOffset(" + str(cursorGoto - decrement) + ")\n")
					inputfile.write("			self.actionQue.put(act)\n")
					inputfile.write("			act = action()\n")
					inputfile.write("			act.setInsert('')\n")

					print cursorGoto,decrement
					print m.group()[3:-2] + str(m.start()) + '*****'
					#move the cursor,
					if (nontermChar == "$"):
						inputfile.write("			self." + str(nontermName) + "()\n")
					elif (nontermChar == "%"):
						inputfile.write("			" + "#alright we need to wait for her to enter a symbol name \n")
						inputfile.write("			" + "self.getSym()\n")

					decrement = nontermSize + cursorGoto
				else:
					inputfile.write("			act.setOffset(0)\n")
					inputfile.write("			self.actionQue.put(act)\n")			
					

			print 'elsing'
			inputfile.write("		else:\n")
			inputfile.write("			self." + i +"()\n")
								
		inputfile.write("\n\n#specifies what text to insert and then where to move\n")
		inputfile.write("class action():\n")
		inputfile.write("	def __init__(self):\n")
		inputfile.write("		pass\n")
		inputfile.write("	def setInsert(self,toinsert):\n")
		inputfile.write("		self.toinsert = toinsert\n")
		inputfile.write("	def setOffset(self,offset):\n")
		inputfile.write("		self.offset = offset\n")

		##annnnnd close the file
		inputfile.close()


